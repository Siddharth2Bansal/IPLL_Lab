extern scanf
extern printf
global main
default rel  ; use this by default for efficiency. This is even mandatory if you run your code on macOS.



section .data

    test1 db "wow", 0;
    Input_format db " %d", 0;
    outLine db "The Sorted array in ascending order is:", 0;
    newLine db "", 0xA, 0;
    output_fmt db " %d", 0;

section .bss

    n: resd 1 ;reserves one double(4 bytes) for int variable
    k: resd 1
    char_buf: resb 1
    arr: resd 20
    e_code: resd 1
    int_buf: resd 1


section .text
main:
; scan n and k from stdin
push rbp ; align stack
mov rdi, Input_format ;loading format
mov rsi, n 
call scanf
mov rdi, Input_format ;loading format
mov rsi, k
call scanf
pop rbp  ;restores stack

; push rbp ;realign stack

; scan n integers from stdin
movsx rbx, dword [n]
mov r12, arr
push rbp
scan_loop:
mov rdi, Input_format
mov rsi, r12
call scanf
dec rbx
add r12, 4
cmp rbx, 0x0
jne scan_loop
pop rbp



; set exit code and find number of elements to add
mov dword [e_code], 0
mov r12d, dword [n]
cmp r12d, dword [k]

jge sel_sort
mov dword [e_code], 1
mov dword [k], r12d


sel_sort:

mov r12, 0
outer:
mov r13, r12
mov r14d, [arr + 4* r12]
mov r15, r13
inner:
cmp r14d, [arr + 4* r13]
jle not_swap
mov r14d, [arr + 4* r13]
mov r15, r13
not_swap:
inc r13
cmp r13d, [n]
jne inner
mov r11d, [arr + 4* r12]
mov [arr + 4* r15], r11d
mov [arr + 4* r12], r14d
inc r12
cmp r12d, [n]
jne outer


; print array
mov r12, 0
mov rdi, outLine
mov al, 0
call printf

print_loop:

mov rdi, output_fmt
mov rsi, [arr + 4* r12]
mov al, 0
call printf
inc r12
cmp r12d, [n]
jne print_loop

mov rdi, newLine
mov al, 0
call printf

mov rdi, output_fmt
movsx r12, dword [n]
sub r12d, [k]
mov rsi, [arr + 4* r12]
mov al, 0
call printf

; ; pop rbp
; ;simulates return 0
movsx rax, dword [e_code]
; mov rax, 0
ret


extern scanf
extern printf

global main
default rel  ; use this by default for efficiency. This is even mandatory if you run your code on macOS.



section .data
number: dq 1.234
str: db "%lf", 0xA, 0
a: dd 1.23
b: dd 1.27

section .bss
temp: resq 1


section .text
main:

cvtss2sd xmm0,[a] ; load from memory
addsd xmm0,xmm0 ; add to itself (double it)
movq [a], xmm0
push rbp


; movq xmm0, qword [number]   ; floating point in str
mov rdi, str                ; address of format string
mov rsi, [a]
mov rax, 1                  ; 1 floating point argument to printf
call printf


pop rbp
mov rax, 0

ret

; movss xmm3,[a]
; ucomiss xmm3,[b]
; jge wejumped
; mov eax, 1
; ret

; wejumped:
; mov eax,3
; ret


